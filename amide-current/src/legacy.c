/* legacy.c - for loading in .xif files previous to the 2.0 format,
 * these files were generated by amide versions previous to 0.7.0
 *
 *
 * Part of amide - Amide's a Medical Image Dataset Examiner
 * Copyright (C) 2000-2002 Andy Loening
 *
 * Author: Andy Loening <loening@ucla.edu>
 */

/*
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
  02111-1307, USA.
*/


#include "legacy.h"

/* external variables */
static gchar * roi_type_names[] = {
  "Ellipsoid", 
  "Elliptic Cylinder", 
  "Box",
  "2D Isocontour",
  "3D Isocontour"
};
#define NUM_ROI_TYPES 5

static gchar * modality_names[] = {
  "PET",
  "SPECT", 
  "CT", 
  "MRI", 
  "Other"
};

#define NUM_MODALITIES 5

static gchar * threshold_names[] = {
  "per slice", 
  "per frame", 
  "interpolated between frames",
  "global"
};

#define NUM_THRESHOLDS 4


static AmitkVoxel voxel3d_read_xml(xmlNodePtr nodes, gchar * descriptor) {

  gchar * temp_string;
  AmitkVoxel return_vp;
  gint x,y,z;
  gint error;

  temp_string = xml_get_string(nodes, descriptor);

  if (temp_string != NULL) {

    /* convert to a voxel */
    error = sscanf(temp_string,"%d\t%d\t%d", &x,&y,&z);
    g_free(temp_string);
    
    return_vp.x = x;
    return_vp.y = y;
    return_vp.z = z;
    return_vp.t = 1;

  } 

  if ((temp_string == NULL) || (error == EOF)) {
    return_vp.x = return_vp.y = return_vp.z = return_vp.t = 0;
    g_warning("Couldn't read value for %s, substituting [%d %d %d %d]",descriptor,
	      return_vp.x, return_vp.y, return_vp.z, return_vp.t);
  }

  return return_vp;
}


/* function to load in a data set xml file */
static AmitkRawData * data_set_load_xml(gchar * data_set_xml_filename) { 

  xmlDocPtr doc;
  AmitkRawData * new_data_set;
  xmlNodePtr nodes;
  AmitkRawFormat i_raw_data_format, raw_data_format;
  gchar * temp_string;
  gchar * data_set_raw_filename;
  AmitkVoxel dim;

  /* parse the xml file */
  if ((doc = xmlParseFile(data_set_xml_filename)) == NULL) {
    g_warning("Couldn't Parse AMIDE data_set xml file %s",data_set_xml_filename);
    return NULL;
  }

  /* get the root of our document */
  if ((nodes = xmlDocGetRootElement(doc)) == NULL) {
    g_warning("Data Set xml file doesn't appear to have a root: %s", data_set_xml_filename);
    return NULL;
  }

  /* get the document tree */
  nodes = nodes->children;

  /* figure out the data format */
  temp_string = xml_get_string(nodes, "raw_data_format");
#if (G_BYTE_ORDER == G_BIG_ENDIAN)
  raw_data_format = AMITK_RAW_FORMAT_DOUBLE_BE;
#else /* (G_BYTE_ORDER == G_LITTLE_ENDIAN) */
  raw_data_format = AMITK_RAW_FORMAT_DOUBLE_LE;
#endif
  if (temp_string != NULL)
    for (i_raw_data_format=0; i_raw_data_format < AMITK_RAW_FORMAT_NUM; i_raw_data_format++) 
      if (g_strcasecmp(temp_string, amitk_raw_format_names[i_raw_data_format]) == 0)
	raw_data_format = i_raw_data_format;
  g_free(temp_string);

  /* get the rest of the parameters */
  dim = amitk_voxel_read_xml(nodes, "dim");

  /* get the name of our associated data file */
  data_set_raw_filename = xml_get_string(nodes, "raw_data_file");

  /* now load in the raw data */
#ifdef AMIDE_DEBUG
  g_print("reading data from file %s\n", data_set_raw_filename);
#endif
  new_data_set = amitk_raw_data_import_raw_file(data_set_raw_filename, raw_data_format, dim, 0);
   
  /* and we're done */
  g_free(data_set_raw_filename);
  xmlFreeDoc(doc);

  return new_data_set;
}

/* function to load in an alignment point xml file */
static AmitkFiducialMark * align_pt_load_xml(gchar * pt_xml_filename) {

  xmlDocPtr doc;
  AmitkFiducialMark * new_pt;
  xmlNodePtr nodes;
  gchar * temp_string;


  /* parse the xml file */
  if ((doc = xmlParseFile(pt_xml_filename)) == NULL) {
    g_warning("Couldn't Parse AMIDE alignment point xml file %s",pt_xml_filename);
    return NULL;
  }

  /* get the root of our document */
  if ((nodes = xmlDocGetRootElement(doc)) == NULL) {
    g_warning("AMIDE alignment point xml file doesn't appear to have a root: %s",pt_xml_filename);
    return NULL;
  }

  new_pt = amitk_fiducial_mark_new();

  /* get the name */
  temp_string = xml_get_string(nodes->children, "text");
  if (temp_string != NULL) {
    amitk_object_set_name(AMITK_OBJECT(new_pt), temp_string);
    g_free(temp_string);
  }

  /* get the document tree */
  nodes = nodes->children;

  /* get the point */
  new_pt->point = amitk_point_read_xml(nodes, "point");
  /* and we're done */
  xmlFreeDoc(doc);
  
  return new_pt;
}


/* function to load in a list of alignment point xml nodes */
static GList * align_pts_load_xml(xmlNodePtr node_list) {

  gchar * file_name;
  GList * new_pts;
  AmitkFiducialMark * new_pt;

  if (node_list != NULL) {
    /* first, recurse on through the list */
    new_pts = align_pts_load_xml(node_list->next);

    /* load in this node */
    file_name = xml_get_string(node_list->children, "text");
    new_pt = align_pt_load_xml(file_name);
    new_pts = g_list_prepend(new_pts, new_pt);
    g_free(file_name);

  } else
    new_pts = NULL;

  return new_pts;
}



/* function to load in a volume xml file */
static AmitkDataSet * volume_load_xml(gchar * volume_xml_filename) {

  xmlDocPtr doc;
  AmitkDataSet * new_volume;
  xmlNodePtr nodes;
  xmlNodePtr pts_nodes;
  AmitkModality i_modality;
  AmitkColorTable i_color_table;
  AmitkThresholding i_thresholding;
  gchar * temp_string;
  gchar * scan_date;
  gchar * data_set_xml_filename;
  gchar * internal_scaling_xml_filename;
  GList * align_pts;
  GList * temp_pts;
  AmitkSpace * space;

  /* parse the xml file */
  if ((doc = xmlParseFile(volume_xml_filename)) == NULL) {
    g_warning("Couldn't Parse AMIDE volume xml file %s",volume_xml_filename);
    return NULL;
  }

  /* get the root of our document */
  if ((nodes = xmlDocGetRootElement(doc)) == NULL) {
    g_warning("AMIDE volume xml file doesn't appear to have a root: %s", volume_xml_filename);
    return NULL;
  }

  new_volume = amitk_data_set_new();

  /* get the volume name */
  temp_string = xml_get_string(nodes->children, "text");
  if (temp_string != NULL) {
    amitk_object_set_name(AMITK_OBJECT(new_volume),temp_string);
    g_free(temp_string);
  }

  /* get the document tree */
  nodes = nodes->children;

  /* get the date the scan was made */
  scan_date = xml_get_string(nodes, "scan_date");
  amitk_data_set_set_scan_date(new_volume, scan_date);
  g_free(scan_date);

  /* figure out the modality */
  temp_string = xml_get_string(nodes, "modality");
  if (temp_string != NULL)
    for (i_modality=0; i_modality < NUM_MODALITIES; i_modality++) 
      if (g_strcasecmp(temp_string, modality_names[i_modality]) == 0)
	new_volume->modality = i_modality;
  g_free(temp_string);

  /* figure out the color table */
  temp_string = xml_get_string(nodes, "color_table");
  if (temp_string != NULL)
    for (i_color_table=0; i_color_table < AMITK_COLOR_TABLE_NUM; i_color_table++) 
      if (g_strcasecmp(temp_string, color_table_menu_names[i_color_table]) == 0)
	new_volume->color_table = i_color_table;
  g_free(temp_string);

  /* load in our data set */
  data_set_xml_filename = xml_get_string(nodes, "data_set_file");
  internal_scaling_xml_filename = xml_get_string(nodes, "internal_scaling_file");
  if ((data_set_xml_filename != NULL) && (internal_scaling_xml_filename != NULL)) {
    new_volume->raw_data = data_set_load_xml(data_set_xml_filename);
    new_volume->internal_scaling = data_set_load_xml(internal_scaling_xml_filename);

    /* the type of internal_scaling has been changed to double
       as of amide 0.7.1 */
    if (new_volume->internal_scaling->format != AMITK_FORMAT_DOUBLE) {
      AmitkRawData * old_scaling;
      AmitkVoxel i;

      g_warning("wrong type found on internal scaling, converting to double");
      old_scaling = new_volume->internal_scaling;

      if ((new_volume->internal_scaling = amitk_raw_data_new()) == NULL) {
	g_warning("couldn't allocate space for the new scaling structure");
	g_object_unref(new_volume);
	return NULL;
      }
      new_volume->internal_scaling->dim = old_scaling->dim;
      new_volume->internal_scaling->format = AMITK_FORMAT_DOUBLE;
      if (new_volume->internal_scaling->data != NULL)
	g_free(new_volume->internal_scaling->data);
      if ((new_volume->internal_scaling->data = amitk_raw_data_get_data_mem(new_volume->internal_scaling)) == NULL) {
	g_warning("Couldn't allocate space for the new scaling factors");
	g_object_unref(new_volume);
	return NULL;
      }
      
      for (i.t=0; i.t<new_volume->internal_scaling->dim.t; i.t++)
	for (i.z=0; i.z<new_volume->internal_scaling->dim.z; i.z++)
	  for (i.y=0; i.y<new_volume->internal_scaling->dim.y; i.y++)
	    for (i.x=0; i.x<new_volume->internal_scaling->dim.x; i.x++)
	      AMITK_RAW_DATA_DOUBLE_SET_CONTENT(new_volume->internal_scaling,i) = 
		amitk_raw_data_get_value(old_scaling, i);
      
      g_object_unref(old_scaling);
    }

    /* parameters that aren't in older versions and default values aren't good enough*/
    amitk_data_set_set_scale_factor(new_volume, xml_get_data(nodes, "external_scaling"));

  } else {
    /* ---- legacy cruft previous to .xif version 1.4 ----- */

    gchar * raw_data_filename;
    AmitkRawFormat i_raw_data_format, raw_data_format;
    AmitkVoxel temp_dim;

    g_warning("no data_set file, will continue with the assumption of a .xif format previous to 1.4");

    /* get the name of our associated data file */
    raw_data_filename = xml_get_string(nodes, "raw_data");

    /* and figure out the data format */
    temp_string = xml_get_string(nodes, "data_format");
#if (G_BYTE_ORDER == G_BIG_ENDIAN)
    raw_data_format = AMITK_RAW_FORMAT_DOUBLE_BE; 
#else /* (G_BYTE_ORDER == G_LITTLE_ENDIAN) */
    raw_data_format = AMITK_RAW_FORMAT_DOUBLE_LE; 
#endif
    if (temp_string != NULL)
      for (i_raw_data_format=0; i_raw_data_format < AMITK_RAW_FORMAT_NUM; i_raw_data_format++) 
	if (g_strcasecmp(temp_string, amitk_raw_format_names[i_raw_data_format]) == 0)
	  raw_data_format = i_raw_data_format;
    g_free(temp_string);

    temp_dim = voxel3d_read_xml(nodes, "dim");
    temp_dim.t = xml_get_int(nodes, "num_frames");
    amitk_data_set_set_scale_factor(new_volume,  xml_get_data(nodes, "conversion"));
    
    /* now load in the raw data */
    new_volume->raw_data = amitk_raw_data_import_raw_file(raw_data_filename, raw_data_format, temp_dim, 0);
    
    g_free(raw_data_filename);
    /* -------- end legacy cruft -------- */
  }

  /* load in the alignment points */
  pts_nodes = xml_get_node(nodes, "Alignment_points");
  if (pts_nodes != NULL) {
    pts_nodes = pts_nodes->children;
    if (pts_nodes != NULL) {
      align_pts = align_pts_load_xml(pts_nodes);
      temp_pts = align_pts;
      while (temp_pts != NULL) {
	amitk_space_copy_in_place(AMITK_SPACE(temp_pts->data), AMITK_SPACE(new_volume));
	temp_pts = temp_pts->next;
      }
      amitk_object_add_children(AMITK_OBJECT(new_volume), align_pts);
      amitk_objects_unref(align_pts);
    }
  }

  /* and figure out the rest of the parameters */
  new_volume->voxel_size = amitk_point_read_xml(nodes, "voxel_size");
  new_volume->scan_start = xml_get_time(nodes, "scan_start");
  new_volume->frame_duration = xml_get_times(nodes, "frame_duration", 
					     AMITK_DATA_SET_NUM_FRAMES(new_volume));
  new_volume->threshold_max[0] =  xml_get_data(nodes, "threshold_max");
  new_volume->threshold_min[0] =  xml_get_data(nodes, "threshold_min");
  new_volume->threshold_max[1] =  xml_get_data(nodes, "threshold_max_1");
  new_volume->threshold_min[1] =  xml_get_data(nodes, "threshold_min_1");
  new_volume->threshold_ref_frame[0] = xml_get_int(nodes,"threshold_ref_frame_0");
  new_volume->threshold_ref_frame[1] = xml_get_int(nodes,"threshold_ref_frame_1");

  space = amitk_space_read_xml(nodes, "coord_frame");
  amitk_space_copy_in_place(AMITK_SPACE(new_volume), space);
  g_object_unref(space);

  /* figure out the thresholding */
  temp_string = xml_get_string(nodes, "threshold_type");
  if (temp_string != NULL)
    for (i_thresholding=0; i_thresholding < NUM_THRESHOLDS; i_thresholding++) 
      if (g_strcasecmp(temp_string, threshold_names[i_thresholding]) == 0)
	new_volume->thresholding = i_thresholding;
  g_free(temp_string);


  /* recalc the temporary parameters */
  amitk_data_set_calc_far_corner(new_volume);
  amitk_data_set_calc_frame_max_min(new_volume);
  amitk_data_set_calc_global_max_min(new_volume);

  /* and we're done */
  xmlFreeDoc(doc);
  
  return new_volume;
}


/* function to load in a list of volume xml nodes */
static GList * volumes_load_xml(xmlNodePtr node_list) {

  gchar * file_name;
  GList * new_data_sets;
  AmitkDataSet * new_ds;

  if (node_list != NULL) {
    /* first, recurse on through the list */
    new_data_sets = volumes_load_xml(node_list->next);

    /* load in this node */
    file_name = xml_get_string(node_list->children, "text");
    new_ds = volume_load_xml(file_name);
    new_data_sets = g_list_prepend(new_data_sets, new_ds);
    g_free(file_name);

  } else
    new_data_sets = NULL;

  return new_data_sets;
}


/* function to load in an ROI xml file */
AmitkRoi * roi_load_xml(gchar * roi_xml_filename) {

  xmlDocPtr doc;
  AmitkRoi * new_roi;
  xmlNodePtr nodes;
  AmitkRoiType i_roi_type;
  gchar * temp_string;
  gchar * isocontour_xml_filename;
  AmitkSpace * space;


  /* parse the xml file */
  if ((doc = xmlParseFile(roi_xml_filename)) == NULL) {
    g_warning("Couldn't Parse AMIDE ROI xml file %s",roi_xml_filename);
    return NULL;
  }

  /* get the root of our document */
  if ((nodes = xmlDocGetRootElement(doc)) == NULL) {
    g_warning("AMIDE ROI xml file doesn't appear to have a root: %s", roi_xml_filename);
    return NULL;
  }
  
  new_roi = amitk_roi_new(0);

  /* get the roi name */
  temp_string = xml_get_string(nodes->children, "text");
  if (temp_string != NULL) {
    amitk_object_set_name(AMITK_OBJECT(new_roi),temp_string);
    g_free(temp_string);
  }

  /* get the document tree */
  nodes = nodes->children;

  /* figure out the type */
  temp_string = xml_get_string(nodes, "type");
  if (temp_string != NULL)
    for (i_roi_type=0; i_roi_type < NUM_ROI_TYPES; i_roi_type++) 
      if (g_strcasecmp(temp_string, roi_type_names[i_roi_type]) == 0)
	new_roi->type = i_roi_type;
  g_free(temp_string);

  /* and figure out the rest of the parameters */
  space = amitk_space_read_xml(nodes, "coord_frame");
  amitk_space_copy_in_place(AMITK_SPACE(new_roi), space);
  g_object_unref(space);

  amitk_volume_set_corner(AMITK_VOLUME(new_roi), amitk_point_read_xml(nodes, "corner"));

  /* isocontour specific stuff */
  if ((AMITK_ROI_TYPE(new_roi) == AMITK_ROI_TYPE_ISOCONTOUR_2D) || 
      (AMITK_ROI_TYPE(new_roi) == AMITK_ROI_TYPE_ISOCONTOUR_3D)) {
    new_roi->voxel_size = amitk_point_read_xml(nodes, "voxel_size");
    new_roi->isocontour_value = xml_get_real(nodes, "isocontour_value");

    isocontour_xml_filename = xml_get_string(nodes, "isocontour_file");
    if (isocontour_xml_filename != NULL)
      new_roi->isocontour = data_set_load_xml(isocontour_xml_filename);
  }

  /* children were never used */

  /* make sure to mark the roi as undrawn if needed */
  if ((AMITK_ROI_TYPE(new_roi) == AMITK_ROI_TYPE_ISOCONTOUR_2D) || 
      (AMITK_ROI_TYPE(new_roi) == AMITK_ROI_TYPE_ISOCONTOUR_3D)) {
    if (new_roi->isocontour == NULL) 
      AMITK_VOLUME(new_roi)->valid = FALSE;
  } else {
    if (POINT_EQUAL(AMITK_VOLUME_CORNER(new_roi), zero_point)) {
      AMITK_VOLUME(new_roi)->valid = FALSE;
    }
  }
   
  /* and we're done */
  xmlFreeDoc(doc);

  return new_roi;
}


/* function to load in a list of ROI xml nodes */
static GList * rois_load_xml(xmlNodePtr node_list) {

  gchar * roi_xml_filename;
  GList * new_rois;
  AmitkRoi * new_roi;

  if (node_list != NULL) {
    /* first, recurse on through the list */
    new_rois = rois_load_xml(node_list->next);

    /* load in this node */
    roi_xml_filename = xml_get_string(node_list->children, "text");
    new_roi = roi_load_xml(roi_xml_filename);
    new_rois = g_list_prepend(new_rois, new_roi);
    g_free(roi_xml_filename);
  } else
    new_rois = NULL;

  return new_rois;
}

AmitkStudy * legacy_load_xml(void) {

  AmitkStudy * study = NULL;
  AmitkSpace * space;
  AmitkPoint view_center;
  xmlDocPtr doc;
  xmlNodePtr nodes;
  xmlNodePtr object_nodes;
  gchar * temp_string;
  gchar * file_version;
  gchar * creation_date;
  GList * objects;
  

  /* warn that this is an old file version */
  g_warning("A .xif file previous to file version 2.0 found.\n"
	    "Invoking legacy loader, please resave file as soon as possible");


  /* parse the xml file */
  if ((doc = xmlParseFile("Study.xml")) == NULL) {
    g_warning("Couldn't Parse AMIDE xml file:\n\tStudy.xml");
    return NULL;
  }

  /* get the root of our document */
  if ((nodes = xmlDocGetRootElement(doc)) == NULL) {
    g_warning("AMIDE xml file doesn't appear to have a root:\n\tStudy.xml");
    return NULL;
  }

  study = amitk_study_new();

  /* get the study name */
  temp_string = xml_get_string(nodes->children, "text");
  if (temp_string != NULL) {
    amitk_object_set_name(AMITK_OBJECT(study),temp_string);
    g_free(temp_string);
  }

  /* get the document tree */
  nodes = nodes->children;

  /* get the version of the data file */
  file_version = xml_get_string(nodes, "AMIDE_Data_File_Version");


  /* get the creation date of the study */
  creation_date = xml_get_string(nodes, "creation_date");
  amitk_study_set_creation_date(study, creation_date);
  g_free(creation_date);

  /* get our study parameters */
  space = amitk_space_read_xml(nodes, "coord_frame");
  amitk_space_copy_in_place(AMITK_SPACE(study), space);
  g_object_unref(space);

  /* load in the volumes */
  object_nodes = xml_get_node(nodes, "Volumes");
  object_nodes = object_nodes->children;
  objects = volumes_load_xml(object_nodes);
  amitk_object_add_children(AMITK_OBJECT(study), objects);
  amitk_objects_unref(objects);

  /* load in the rois */
  object_nodes = xml_get_node(nodes, "ROIs");
  object_nodes = object_nodes->children;
  objects = rois_load_xml(object_nodes);
  amitk_object_add_children(AMITK_OBJECT(study), objects);
  amitk_objects_unref(objects);

  /* get our view parameters */
  view_center = amitk_point_read_xml(nodes, "view_center");
  amitk_study_set_view_center(study, amitk_space_s2b(AMITK_SPACE(study), view_center));
  amitk_study_set_view_thickness(study, xml_get_real(nodes, "view_thickness"));
  amitk_study_set_view_start_time(study, xml_get_time(nodes, "view_time"));
  amitk_study_set_view_duration(study, xml_get_time(nodes, "view_duration"));
  amitk_study_set_zoom(study, xml_get_real(nodes, "zoom"));
 
  /* sanity check */
  if (AMITK_STUDY_ZOOM(study) < SMALL_DISTANCE) {
    g_warning("inappropriate zoom (%5.3f) for study, reseting to 1.0",AMITK_STUDY_ZOOM(study));
    amitk_study_set_zoom(study, 1.0);
  }

  /* figure out the interpolation */
  temp_string = xml_get_string(nodes, "interpolation");
  amitk_study_set_interpolation(study, AMITK_INTERPOLATION_NEAREST_NEIGHBOR);
  if (temp_string != NULL)
    if (g_strcasecmp(temp_string, "Trilinear") == 0)
      amitk_study_set_interpolation(study, AMITK_INTERPOLATION_TRILINEAR);
  g_free(temp_string);

  /* and we're done */
  xmlFreeDoc(doc);
    
  /* legacy cruft, rip out at some point in the future */
  /* compensate for errors in old versions of amide */
  if (g_strcasecmp(file_version, "1.3") < 0) {
    GList * objects;
    AmitkObject * object;
    AmitkPoint new_axes[AMITK_AXIS_NUM];
    AmitkPoint new_offset;
    AmitkAxis i_axis;

    g_warning("detected file version previous to 1.3, compensating for coordinate errors");

    view_center = AMITK_STUDY_VIEW_CENTER(study);
    view_center.y = -view_center.y;
    amitk_study_set_view_center(study,view_center);

    objects = AMITK_OBJECT_CHILDREN(study);
    while (objects != NULL) {
      object = objects->data;


      for (i_axis=0;i_axis<AMITK_AXIS_NUM;i_axis++)
	new_axes[i_axis] = amitk_space_get_axis(AMITK_SPACE(object), i_axis);
      new_axes[AMITK_AXIS_X].y = -new_axes[AMITK_AXIS_X].y;
      new_axes[AMITK_AXIS_Y].y = -new_axes[AMITK_AXIS_Y].y;
      new_axes[AMITK_AXIS_Z].y = -new_axes[AMITK_AXIS_Z].y;
      amitk_space_set_axes(AMITK_SPACE(object), new_axes, AMITK_SPACE_OFFSET(object));

      new_offset = AMITK_SPACE_OFFSET(object);
      new_offset.y = -new_offset.y;
      amitk_space_set_offset(AMITK_SPACE(object), new_offset);

      objects = objects->next;
    }

  }

  /* freeing up anything we haven't freed yet */
  g_free(file_version);


  return study;

}


